package bpf

import (
	"bufio"
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"os"
	"os/signal"
	"syscall"

	"github.com/cilium/ebpf/ringbuf"

	"github.com/cilium/ebpf/link"
	"go.uber.org/zap"
)

var (
	ErrCfgInvalid             = errors.New("invalid config")
	ErrInvalidSyscallNr       = errors.New("invalid syscall number")
	ErrFilenameMarshalFailed  = errors.New("failed to marshal filename")
	ErrBadLibcRange           = errors.New("nonsensical libc range given")
	ErrWhitelistAlreadyExists = errors.New("whitelist already exists")
)

type Stats struct {
	GetCurrentTaskFailed uint64
	TPEntered            uint64
	GetProfilerFailed    uint64
	IgnorePID            uint64
	ReadPIDFailed        uint64
	ReadPPIDFailed       uint64
	FollowForkFailed     uint64
	LibcNotLoaded        uint64
	StackDebugEmpty      uint64
	GetStackFailed       uint64
	CallsiteLibc         uint64
	StackTooShort        uint64
	NoRPMapping          uint64
	RPNullAfterMap       uint64
	FilenameTooLong      uint64
	FindVMAFailed        uint64
	NoBackingVMA         uint64
	WhitelistMissing     uint64
	SyscallBlocked       uint64
	SendSignalFailed     uint64
}

type Stacktrace struct {
	Stack        [32]uint64
	FramesWalked int32
	CallSite     uint64
}

// WarnMode specifies what action the filter should take when a blacklisted syscall is detected
// (can't be publicly autogenerated).
type WarnMode string

var (
	// KillPID specifies that only the "malicious" PID is killed when a disallowed syscall happens.
	KillPID WarnMode = "kill-pid"
	// KillAll specifies that all PIDs being traced are killed when a disallowed syscall happens.
	KillAll WarnMode = "kill-all"
	// Warn will simply warn userspace when a disallowed syscall happens - nothing is killed.
	Warn WarnMode = "warn"
)

func StrToWarnMode(s string) (WarnMode, error) {
	switch s {
	case string(KillPID):
		return KillPID, nil
	case string(KillAll):
		return KillAll, nil
	case string(Warn):
		return Warn, nil
	default:
	}

	return "", fmt.Errorf("%w: unrecognised warn mode", ErrCfgInvalid)
}

type FilterCfg struct {
	Action  WarnMode
	Profile bool
}

// Filter is the userspace counterpart to the `addrfilter` bpf program.
//
// It provides functionality to attach the bpf program to its tracepoint, as well as operations to interact with maps.
//
// Filter doesn't contain any business logic.
type Filter struct {
	Cfg        *FilterCfg
	logger     *zap.SugaredLogger
	objects    *addrfilterObjects
	tracepoint *link.Link
	profiler   *Profiler
}

// LoadFilter will load the addrfilter bpf program. If cfg==nil, Filter defaults to killing just the "malicious" PID.
func LoadFilter(logger *zap.SugaredLogger, cfg *FilterCfg) (*Filter, error) {
	if cfg == nil {
		cfg = &FilterCfg{
			Action:  KillPID,
			Profile: false,
		}
	}

	p := &Filter{
		Cfg:     cfg,
		logger:  logger,
		objects: &addrfilterObjects{},
	}

	err := loadAddrfilterObjects(p.objects, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to load addrfilter objects: %w", err)
	}

	if cfg.Profile {
		f, err := os.Create("prof.csv")
		if err != nil {
			p.logger.Warnw("failed to create prof.csv, profiling to stdout", "err", err)
			f = os.Stdout
		}

		bufOut := bufio.NewWriter(f)

		p.profiler, err = NewProfiler(logger, p.objects.ProfileBuf, bufOut)
		if err != nil {
			return nil, fmt.Errorf("failed to create profiler: %w", err)
		}
	}

	return p, nil
}

// Start attaches the addrfilter program to the raw_tp hook and blocks until the context is cancelled.
func (f *Filter) Start(ctx context.Context) error {
	if err := f.initMaps(); err != nil {
		return fmt.Errorf("failed to initialise maps: %w", err)
	}

	tp, err := link.AttachRawTracepoint(link.RawTracepointOptions{
		Name:    "sys_enter",
		Program: f.objects.Addrfilter,
	})
	if err != nil {
		return fmt.Errorf("failed to attack to raw tracepoint: %w", err)
	}
	defer tp.Close()

	go func() {
		if err := f.Listen(ctx); err != nil {
			f.logger.Warnw("error listening for warnings from kernel space: %w", err)
		}
	}()

	if f.profiler != nil {
		go func() {
			if err := f.profiler.Monitor(ctx); err != nil {
				f.logger.Warnw("error listening for profiling information", "err", err)
			}
		}()
	}

	for range ctx.Done() {
	}

	return nil
}

// ProtectPID will add a PID to the filter list.
func (f *Filter) ProtectPID(pid int32) error {
	f.logger.Infow("adding process to filter list", "pid", pid)

	if err := f.objects.ProtectMap.Put(pid, true); err != nil {
		return fmt.Errorf("failed to register pid into follow map: %w", err)
	}

	return nil
}

// RegisterLibc associates an address mapping with libc for a given process.
//
// addrfilter assumes that libc is one continuous mapping which doesn't change as the program executes
//
// Libc range is used by BPF to identify which return pointers from the stack
// belong to libc. Since the aim is to identify a non-libc syscall site, the
// bpf program will ignore all return pointers in this range.
func (f *Filter) RegisterLibc(pid int32, start, end uint64) error {
	if end <= start {
		return fmt.Errorf("%w: end cannot be less than start", ErrBadLibcRange)
	}

	f.logger.Infow("updating libc address space",
		"pid", pid,
		"start", fmt.Sprintf("0x%x", start),
		"end", fmt.Sprintf("0x%x", end),
	)

	if err := f.objects.LibcRangeMap.Put(
		int32(zero),
		addrfilterVmRange{
			Start:    start,
			End:      end,
			Filename: [256]int8{},
		},
	); err != nil {
		return fmt.Errorf("failed to insert vmrange for pid: %w", err)
	}

	return nil
}

// initMaps will initialise all maps (except the follow map).
func (f *Filter) initMaps() error {
	initFns := []func(*addrfilterObjects) error{
		initStatsMap,
		initStacktraceDebugMap,
	}

	for _, fn := range initFns {
		if err := fn(f.objects); err != nil {
			return fmt.Errorf("failed to initialise map: %w", err)
		}
	}

	return nil
}

// ReadStatsMap will report Stats of execution.
func (f *Filter) ReadStatsMap() (*Stats, error) {
	stats := make([]uint64, addrfilterStatTypeSTAT_END)

	ss := []addrfilterStatType{
		addrfilterStatTypeGET_CUR_TASK_FAILED,
		addrfilterStatTypeTP_ENTERED,
		addrfilterStatTypeGET_PROFILER_FAILED,
		addrfilterStatTypeIGNORE_PID,
		addrfilterStatTypePID_READ_FAILED,
		addrfilterStatTypePPID_READ_FAILED,
		addrfilterStatTypeFOLLOW_FORK_FAILED,
		addrfilterStatTypeLIBC_NOT_LOADED,
		addrfilterStatTypeSTK_DBG_EMPTY,
		addrfilterStatTypeGET_STACK_FAILED,
		addrfilterStatTypeCALLSITE_LIBC,
		addrfilterStatTypeSTACK_TOO_SHORT,
		addrfilterStatTypeNO_RP_MAPPING,
		addrfilterStatTypeRP_NULL_AFTER_MAP,
		addrfilterStatTypeFILENAME_TOO_LONG,
		addrfilterStatTypeFIND_VMA_FAILED,
		addrfilterStatTypeNO_VMA_BACKING_FILE,
		addrfilterStatTypeWHITELIST_MISSING,
		addrfilterStatTypeSYSCALL_BLOCKED,
		addrfilterStatTypeSEND_SIGNAL_FAILED,
	}

	for _, s := range ss {
		if err := f.objects.StatsMap.Lookup(&s, &stats[s]); err != nil {
			return nil, fmt.Errorf("failed to read ringbuf full errors: %w", err)
		}
	}

	return &Stats{
		GetCurrentTaskFailed: stats[addrfilterStatTypeGET_CUR_TASK_FAILED],
		TPEntered:            stats[addrfilterStatTypeTP_ENTERED],
		IgnorePID:            stats[addrfilterStatTypeIGNORE_PID],
		GetProfilerFailed:    stats[addrfilterStatTypeGET_PROFILER_FAILED], // only relevant when profiling
		ReadPIDFailed:        stats[addrfilterStatTypePID_READ_FAILED],
		ReadPPIDFailed:       stats[addrfilterStatTypePPID_READ_FAILED],
		FollowForkFailed:     stats[addrfilterStatTypeFOLLOW_FORK_FAILED],
		LibcNotLoaded:        stats[addrfilterStatTypeLIBC_NOT_LOADED],
		StackDebugEmpty:      stats[addrfilterStatTypeSTK_DBG_EMPTY],
		GetStackFailed:       stats[addrfilterStatTypeGET_STACK_FAILED],
		CallsiteLibc:         stats[addrfilterStatTypeCALLSITE_LIBC],
		StackTooShort:        stats[addrfilterStatTypeSTACK_TOO_SHORT],
		NoRPMapping:          stats[addrfilterStatTypeNO_RP_MAPPING],
		RPNullAfterMap:       stats[addrfilterStatTypeRP_NULL_AFTER_MAP],
		FilenameTooLong:      stats[addrfilterStatTypeFILENAME_TOO_LONG],
		FindVMAFailed:        stats[addrfilterStatTypeFIND_VMA_FAILED],
		NoBackingVMA:         stats[addrfilterStatTypeNO_VMA_BACKING_FILE],
		WhitelistMissing:     stats[addrfilterStatTypeWHITELIST_MISSING],
		SyscallBlocked:       stats[addrfilterStatTypeSYSCALL_BLOCKED],
		SendSignalFailed:     stats[addrfilterStatTypeSEND_SIGNAL_FAILED],
	}, nil
}

// ReadLibcMap is a debug function which can be used to dump the output of the libc map
func (f *Filter) ReadLibcMap() (map[int32]*addrfilterVmRange, error) {
	libcMap := make(map[int32]*addrfilterVmRange)

	var (
		pid     int32
		vmRange addrfilterVmRange
	)

	bpfLRM := f.objects.LibcRangeMap.Iterate()
	for {
		next := bpfLRM.Next(&pid, &vmRange)
		if err := bpfLRM.Err(); err != nil {
			return nil, fmt.Errorf("failed to read from protect map: %w", err)
		}

		f.logger.Infow("read from libcRangeMap",
			"pid", pid,
			"start", fmt.Sprintf("0x%x", vmRange.Start),
			"end", fmt.Sprintf("0x%x", vmRange.End),
		)

		if _, ok := libcMap[pid]; ok {
			f.logger.Warnw("duplicate libc entry found in libc map", "pid", pid)
		}
		libcMap[pid] = &addrfilterVmRange{vmRange.Start, vmRange.End, vmRange.Filename}

		if !next {
			break
		}
	}

	return libcMap, nil
}

// ReadStacktraceMap is a debug function which can be used to dump the output of the libc map
func (f *Filter) ReadStacktraceMap() (*Stacktrace, error) {
	var trace addrfilterStackTraceT

	if err := f.objects.StackDbgMap.Lookup(new(int32), &trace); err != nil {
		if errors.Is(err, io.ErrUnexpectedEOF) {
			f.logger.Infow("empty debug map")
			return &Stacktrace{}, nil
		}
		return nil, fmt.Errorf("failed to read from stack dbg map: %w", err)
	}

	f.logger.Infow("stacktrace debug",
		"callsite", trace.Callsite,
		"frames walked", trace.FramesWalked,
		"stacktrace", trace.Stacktrace,
	)

	return &Stacktrace{
		Stack:        trace.Stacktrace,
		FramesWalked: trace.FramesWalked,
		CallSite:     trace.Callsite,
	}, nil
}

func (f *Filter) RegisterWhitelists(whitelist []*Whitelist) error {
	for _, w := range whitelist {
		if err := f.RegisterWhitelist(w); err != nil {
			return fmt.Errorf("failed to register whitelist: %w", err)
		}
	}

	return nil
}

// RegisterWhitelist writes a Whitelist to kernel space.
func (f *Filter) RegisterWhitelist(whitelist *Whitelist) error {
	var w addrfilterSyscallWhitelist

	name, err := whitelist.MarshalFilename()
	if err != nil {
		return fmt.Errorf("failed to marshal filename to byte array: %w", err)
	}

	err = f.objects.PathWhitelistMap.Lookup(&name, &w)
	if err != nil {
		if w.Bitmap != [58]uint8{} {
			return fmt.Errorf("%w: non-zerod bitmap already exists", ErrWhitelistAlreadyExists)
		}
	}

	bitmap, err := whitelist.AsBitmap()
	if err != nil {
		return fmt.Errorf("failed to generate bitmap: %w", err)
	}

	if err := f.objects.PathWhitelistMap.Put(&name, &bitmap); err != nil {
		return fmt.Errorf("failed to write whitelist to kernel space: %w", err)
	}

	return nil
}

// RegisterCfg registers filter config in the kernel
func (f *Filter) RegisterCfg() error {
	key := addrfilterConfigTypeKILL_MODE

	var killmode int32

	switch f.Cfg.Action {
	case KillPID:
		killmode = int32(addrfilterKillModeKILL_PID)
	case KillAll:
		killmode = int32(addrfilterKillModeKILL_ALL)
	case Warn:
		killmode = int32(addrfilterKillModeWARN)
	default:
		return fmt.Errorf("%w: %s unsupported", ErrCfgInvalid, f.Cfg.Action)
	}

	if err := f.objects.CfgMap.Put(&key, &killmode); err != nil {
		return fmt.Errorf("failed to write config to config map: %w", err)
	}

	return nil
}

// Listen (blocks and) listens for reported syscalls, and either kills reported syscalls or warns (depending on config).
func (f *Filter) Listen(ctx context.Context) error {
	rd, err := ringbuf.NewReader(f.objects.WarnBuf)
	if err != nil {
		return fmt.Errorf("failed to get reader to warn ring buffer: %w", err)
	}
	defer rd.Close()

	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)
	defer close(stopper)

	errChan := make(chan error, 16)
	defer close(errChan)

	go func(errChan chan<- error) {
		for {
			record, err := rd.Read() // rd.Read blocks until there is something to read OR the buffer is closed.
			if errors.Is(err, ringbuf.ErrClosed) {
				f.logger.Infow("warn buffer closed, exiting...")
				return
			} else if err != nil {
				errChan <- fmt.Errorf("failed to read from warn ringbuf: %w", err)
			}

			var pid int32

			if err := binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &pid); err != nil {
				errChan <- fmt.Errorf("failed to unmarshall data from warning buffer")
			}

			switch f.Cfg.Action {
			case Warn:
				f.warn(pid, 0) // todo: add syscall number to warning
			case KillAll:
				if err := f.killAll(); err != nil {
					errChan <- fmt.Errorf("failed to kill all processes: %w", err)
				}
			}

		}
	}(errChan)

	// listen on another goroutine so this one can busy wait for a ctx done or interrupt signal.
	// if we also listened to the ringbuffer here, problems would ensue.
	//
	// rd.Read blocks until a read happens, or the buffer is closed.
	// thus, if we listened here, we would never go back and check ctx cancelled, interrupt signal.
	for {
		select {
		case <-ctx.Done():
			return nil
		case <-stopper:
			return nil
		case err := <-errChan:
			f.logger.Warnw("error reading from warn buffer", "err", err)
		}
	}
}

func (f *Filter) killAll() error {
	var pid int32

	bpfPM := f.objects.ProtectMap.Iterate()
	for {
		next := bpfPM.Next(&pid, &pid)
		if err := bpfPM.Err(); err != nil {
			return fmt.Errorf("failed to read from protect map: %w", err)
		}

		if !next {
			break
		}

		p, err := os.FindProcess(int(pid))
		if err != nil {
			f.logger.Warnw("couldn't find process", "pid", pid, "err", err)

			continue
		}

		if err := p.Kill(); err != nil {
			f.logger.Warnw("couldn't kill process", "pid", pid, "err", err)
		}

	}

	return nil
}

func (f *Filter) warn(pid int32, syscallNr uint64) {
	f.logger.Warnw("blacklisted syscall detected", "pid", pid, "syscall-number", syscallNr)
}
