package bpf

import (
	"errors"
	"fmt"
)

var (
	ErrInvalidSyscallNr      = errors.New("invalid syscall number")
	ErrFilenameMarshalFailed = errors.New("failed to marshal filename")
)

type Stats struct {
	GetCurrentTaskFailed uint64
	TPEntered            uint64
	IgnorePID            uint64
	ReadPIDFailed        uint64
	LibcNotLoaded        uint64
	StackDebugEmpty      uint64
	GetStackFailed       uint64
	CallsiteLibc         uint64
	StackTooShort        uint64
	NoRPMapping          uint64
	RPNullAfterMap       uint64
	FilenameTooLong      uint64
	FindVMAFailed        uint64
	NoBackingVMA         uint64
	WhitelistMissing     uint64
	SyscallBlocked       uint64
	SendSignalFailed     uint64
}

type Stacktrace struct {
	Stack        [32]uint64
	FramesWalked int32
	CallSite     uint64
}

// Whitelist associates a filename with a set of allowed syscall numbers
type Whitelist struct {
	Filename string
	Syscalls []uint
}

// AsBitmap returns the bitmap representation of a syscall whitelist.
// If number n appears in Syscalls, then bit position n is set to 1.
// Cannot be autogenerated to be publicly exported.
func (w *Whitelist) AsBitmap() ([58]uint8, error) {
	var bitmap [58]uint8

	for _, syscallNr := range w.Syscalls {
		if syscallNr > 58*8 {
			return bitmap, fmt.Errorf("%w: %d is not a valid syscall number", ErrInvalidSyscallNr, syscallNr)
		}

		bitmap[(syscallNr / 8)] |= 1 << (syscallNr % 8)
	}

	return bitmap, nil
}

func (w *Whitelist) MarshalFilename() ([256]byte, error) {
	bts := [256]byte{}

	if len(w.Filename) > 255 {
		return bts, fmt.Errorf("%w: filename too long %d > 255", ErrFilenameMarshalFailed, len(w.Filename))
	}

	i := 0
	for i < len(w.Filename) {
		bts[i] = w.Filename[i]
		i++
	}

	// add null terminator
	bts[i] = 0x00

	return bts, nil
}
