package bpf

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"go.uber.org/zap"
)

var ErrParamNil = errors.New("unexpected nil pointer")

type Filter struct {
	logger     *zap.SugaredLogger
	objects    *addrfilterObjects
	tracepoint *link.Link
}

// VMRange should have the same fields as addrfilterVmRange but
// cannot publicly export the autogenerated type.
type VMRange struct {
	Start uint64
	End   uint64
}

// LoadFilter will load the addrfilter bpf program.
func LoadFilter(logger *zap.SugaredLogger) (*Filter, error) {
	p := &Filter{
		logger:  logger,
		objects: &addrfilterObjects{},
	}

	if err := loadAddrfilterObjects(p.objects, nil); err != nil {
		return nil, fmt.Errorf("failed to load addrfilter objects: %w", err)
	}

	return p, nil
}

// Start starts filtering, placing any processes that need killing on the kills channel.
func (f *Filter) Start(ctx context.Context, kills chan int32) error {
	if err := f.initMaps(); err != nil {
		return fmt.Errorf("failed to initialise maps: %w", err)
	}

	tp, err := link.AttachRawTracepoint(link.RawTracepointOptions{
		Name:    "sys_enter",
		Program: f.objects.addrfilterPrograms.Addrfilter,
	})
	if err != nil {
		return fmt.Errorf("failed to attack to raw tracepoint: %w", err)
	}
	defer tp.Close()

	// rd, err := ringbuf.NewReader(f.objects.KillMap)
	// if err != nil {
	// 	return fmt.Errorf("failed to get reader to sc_events_map: %w", err)
	// }
	// defer rd.Close()

	// // ringbuf read blocks, so close from up here when context is cancelled.
	// go func() {
	// 	for {
	// 		select {
	// 		case <-ctx.Done():
	// 			rd.Close()
	// 			return
	// 		}
	// 	}
	// }()

	// if err := f.readKills(ctx, rd, kills); err != nil {
	// 	return fmt.Errorf("failed to read from kills map: %w", err)
	// }

	return nil
}

// ProtectPID will add a PID to the filter list.
func (f *Filter) ProtectPID(pid int32) error {
	f.logger.Infow("adding process to filter list", "pid", pid)

	if err := f.objects.ProtectMap.Put(pid, true); err != nil {
		return fmt.Errorf("failed to register pid into follow map: %w", err)
	}

	return nil
}

// RegisterLibc associates an address mapping with libc for a given process.
//
// Libc range is used by BPF to identify which return pointers from the stack
// belong to libc. Since the aim is to identify a non-libc syscall site, the
// bpf program will ignore all return pointers in this range.
func (f *Filter) RegisterLibc(pid int32, vmRange *VMRange) error {
	if vmRange == nil {
		return fmt.Errorf("%w: vmrange is nil", ErrParamNil)
	}

	f.logger.Infow("updating libc address space",
		"pid", pid,
		"start", fmt.Sprintf("0x%x", vmRange.Start),
		"end", fmt.Sprintf("0x%x", vmRange.End),
	)

	if err := f.objects.LibcRangesMap.Put(pid, addrfilterVmRange{Start: vmRange.Start, End: vmRange.End}); err != nil {
		return fmt.Errorf("failed to insert vmrange for pid: %w", err)
	}

	return nil
}

func (f *Filter) readKills(ctx context.Context, rd *ringbuf.Reader, kills chan<- int32) error {
	defer close(kills)

	var kill int32

	for {
		select {
		case <-ctx.Done():
			f.logger.Infow("context cancelled, exiting")
			return nil
		default:
		}

		record, err := rd.Read()
		if errors.Is(err, ringbuf.ErrClosed) {
			f.logger.Info("ringbuffer closed, exiting...")

			return nil
		} else if err != nil {
			return fmt.Errorf("failed to read from ringbuffer: %w", err)
		}

		if err := binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &kill); err != nil {
			return fmt.Errorf("failed to parse binary from bpf map: %w", err)
		}

		kills <- kill
	}
}

// initMaps will initialise all maps (except the follow map).
func (f *Filter) initMaps() error {
	initFns := []func(*addrfilterObjects) error{
		initStatsMap,
		initStacktraceDebugMap,
	}

	for _, fn := range initFns {
		if err := fn(f.objects); err != nil {
			return fmt.Errorf("failed to initialise map: %w", err)
		}
	}

	return nil
}

// ReadStatsMap will report Stats of execution.
func (f *Filter) ReadStatsMap() (*Stats, error) {
	stats := make([]uint64, addrfilterStatTypeSTAT_END)

	ss := []addrfilterStatType{
		addrfilterStatTypeGET_CUR_TASK_FAILED,
		addrfilterStatTypeTP_ENTERED,
		addrfilterStatTypeIGNORE_PID,
		addrfilterStatTypeKILL_RINGBUF_RESERVE_FAILED,
		addrfilterStatTypePID_READ_FAILED,
		addrfilterStatTypeLIBC_NOT_LOADED,
		addrfilterStatTypeGET_STACK_FAILED,
		addrfilterStatTypeCALLSITE_LIBC,
		addrfilterStatTypeSTACK_TOO_SHORT,
		addrfilterStatTypeFILENAME_TOO_LONG,
		addrfilterStatTypeFIND_VMA_FAILED,
	}

	for _, s := range ss {
		if err := f.objects.StatsMap.Lookup(&s, &stats[s]); err != nil {
			return nil, fmt.Errorf("failed to read ringbuf full errors: %w", err)
		}
	}

	return &Stats{
		GetCurrentTaskFailed: stats[addrfilterStatTypeGET_CUR_TASK_FAILED],
		TPEntered:            stats[addrfilterStatTypeTP_ENTERED],
		IgnorePID:            stats[addrfilterStatTypeIGNORE_PID],
		RingbufReserveFailed: stats[addrfilterStatTypeKILL_RINGBUF_RESERVE_FAILED],
		ReadPIDFailed:        stats[addrfilterStatTypePID_READ_FAILED],
		LibcNotLoaded:        stats[addrfilterStatTypeLIBC_NOT_LOADED],
		GetStackFailed:       stats[addrfilterStatTypeGET_STACK_FAILED],
		CallsiteLibc:         stats[addrfilterStatTypeCALLSITE_LIBC],
		StackTooShort:        stats[addrfilterStatTypeSTACK_TOO_SHORT],
		FilenameTooLong:      stats[addrfilterStatTypeFILENAME_TOO_LONG],
		FindVMAFailed:        stats[addrfilterStatTypeFIND_VMA_FAILED],
	}, nil
}

// ReadLibcMap is a debug function which can be used to dump the output of the libc map
func (f *Filter) ReadLibcMap() map[int32]*VMRange {
	libcMap := make(map[int32]*VMRange)

	var (
		pid     int32
		vmRange addrfilterVmRange
	)

	bpfLRM := f.objects.LibcRangesMap.Iterate()
	for {
		next := bpfLRM.Next(&pid, &vmRange)

		f.logger.Infow("read from libcRangeMap",
			"pid", pid,
			"start", fmt.Sprintf("0x%x", vmRange.Start),
			"end", fmt.Sprintf("0x%x", vmRange.End),
		)

		if _, ok := libcMap[pid]; ok {
			f.logger.Warnw("duplicate libc entry found in libc map", "pid", pid)
		}
		libcMap[pid] = &VMRange{vmRange.Start, vmRange.End}

		if !next {
			break
		}
	}

	return libcMap
}

// ReadStacktraceMap is a debug function which can be used to dump the output of the libc map
func (f *Filter) ReadStacktraceMap() (*Stacktrace, error) {
	var trace addrfilterStackTraceT

	if err := f.objects.StackDbgMap.Lookup(new(int32), &trace); err != nil {
		if errors.Is(err, io.ErrUnexpectedEOF) {
			f.logger.Infow("empty debug map")
			return &Stacktrace{}, nil
		}
		return nil, fmt.Errorf("failed to read from stack dbg map: %w", err)
	}

	f.logger.Infow("stacktrace debug",
		"callsite", trace.Callsite,
		"frames walked", trace.FramesWalked,
		"stacktrace", trace.Stacktrace,
	)

	return &Stacktrace{
		Stack:        trace.Stacktrace,
		FramesWalked: trace.FramesWalked,
		CallSite:     trace.Callsite,
	}, nil
}
