// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package bpf

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type addrfilterStatType uint32

const (
	addrfilterStatTypeGET_CUR_TASK_FAILED addrfilterStatType = 0
	addrfilterStatTypeTP_ENTERED          addrfilterStatType = 1
	addrfilterStatTypeIGNORE_PID          addrfilterStatType = 2
	addrfilterStatTypeSTAT_END            addrfilterStatType = 3
)

// loadAddrfilter returns the embedded CollectionSpec for addrfilter.
func loadAddrfilter() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_AddrfilterBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load addrfilter: %w", err)
	}

	return spec, err
}

// loadAddrfilterObjects loads addrfilter and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*addrfilterObjects
//	*addrfilterPrograms
//	*addrfilterMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadAddrfilterObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadAddrfilter()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// addrfilterSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type addrfilterSpecs struct {
	addrfilterProgramSpecs
	addrfilterMapSpecs
	addrfilterVariableSpecs
}

// addrfilterProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type addrfilterProgramSpecs struct {
	Addrfilter *ebpf.ProgramSpec `ebpf:"addrfilter"`
}

// addrfilterMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type addrfilterMapSpecs struct {
	KillMap    *ebpf.MapSpec `ebpf:"kill_map"`
	ProtectMap *ebpf.MapSpec `ebpf:"protect_map"`
	StatsMap   *ebpf.MapSpec `ebpf:"stats_map"`
}

// addrfilterVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type addrfilterVariableSpecs struct {
	UnusedStatType *ebpf.VariableSpec `ebpf:"unused_stat_type"`
}

// addrfilterObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadAddrfilterObjects or ebpf.CollectionSpec.LoadAndAssign.
type addrfilterObjects struct {
	addrfilterPrograms
	addrfilterMaps
	addrfilterVariables
}

func (o *addrfilterObjects) Close() error {
	return _AddrfilterClose(
		&o.addrfilterPrograms,
		&o.addrfilterMaps,
	)
}

// addrfilterMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadAddrfilterObjects or ebpf.CollectionSpec.LoadAndAssign.
type addrfilterMaps struct {
	KillMap    *ebpf.Map `ebpf:"kill_map"`
	ProtectMap *ebpf.Map `ebpf:"protect_map"`
	StatsMap   *ebpf.Map `ebpf:"stats_map"`
}

func (m *addrfilterMaps) Close() error {
	return _AddrfilterClose(
		m.KillMap,
		m.ProtectMap,
		m.StatsMap,
	)
}

// addrfilterVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadAddrfilterObjects or ebpf.CollectionSpec.LoadAndAssign.
type addrfilterVariables struct {
	UnusedStatType *ebpf.Variable `ebpf:"unused_stat_type"`
}

// addrfilterPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadAddrfilterObjects or ebpf.CollectionSpec.LoadAndAssign.
type addrfilterPrograms struct {
	Addrfilter *ebpf.Program `ebpf:"addrfilter"`
}

func (p *addrfilterPrograms) Close() error {
	return _AddrfilterClose(
		p.Addrfilter,
	)
}

func _AddrfilterClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed addrfilter_x86_bpfel.o
var _AddrfilterBytes []byte
