package bpf

import (
	"encoding/json"
	"fmt"
	"maps"
	"path"
)

const FailedSyscallMapping = "FAILED"

// Whitelist associates a filename with a set of allowed syscall numbers
type Whitelist struct {
	Filename string
	Syscalls []uint
}

// AsBitmap returns the bitmap representation of a syscall whitelist.
// If number n appears in Syscalls, then bit position n is set to 1.
// Cannot be autogenerated to be publicly exported.
func (w *Whitelist) AsBitmap() ([58]uint8, error) {
	var bitmap [58]uint8

	for _, syscallNr := range w.Syscalls {
		if syscallNr > 58*8 {
			return bitmap, fmt.Errorf("%w: %d is not a valid syscall number", ErrInvalidSyscallNr, syscallNr)
		}

		bitmap[(syscallNr / 8)] |= 1 << (syscallNr % 8)
	}

	return bitmap, nil
}

func (w *Whitelist) MarshalFilename() ([256]byte, error) {
	bts := [256]byte{}

	if len(w.Filename) > 255 {
		return bts, fmt.Errorf("%w: filename too long %d > 255", ErrFilenameMarshalFailed, len(w.Filename))
	}

	i := 0
	for i < len(w.Filename) {
		bts[i] = w.Filename[i]
		i++
	}

	// add null terminator
	bts[i] = 0x00

	return bts, nil
}

// ParseSysoWhitelists will parse a `syso`-generated `counts.json` file and convert
// it into whitelists which can be loaded into the kernel for filtering purposes.
//
// The `syso` format is JSON of the form
//
//	{
//	  "LIBRARY PATH": {
//	    "SYSCALL NUMBER": [syscall count],
//	    ...
//	  },
//	}
//
// This parse function expects syscall counts as that is the format that `syso` generates by default.
// By expecting these counts, though superfluous, intgration with `syso` is easier.
func ParseSysoWhitelists(sysoWhitelists []byte) ([]*Whitelist, error) {
	var whitelistWCounts map[string]map[uint]int

	if err := json.Unmarshal(sysoWhitelists, &whitelistWCounts); err != nil {
		return nil, fmt.Errorf("unmarshaling failed: %w", err)
	}

	whitelists := make([]*Whitelist, 0)

	for libPath, syscallCounts := range whitelistWCounts {
		file := path.Base(libPath)
		syscalls := maps.Keys(syscallCounts)

		if file == FailedSyscallMapping {
			continue
		}

		whitelist := Whitelist{Filename: file}

		fmt.Printf("%s: ", file)

		for s := range syscalls {
			fmt.Printf("%d, ", s)
			whitelist.Syscalls = append(whitelist.Syscalls, s)
		}

		fmt.Println()

		whitelists = append(whitelists, &whitelist)
	}

	// if any mappings failed, add them to every compartments whitelist.
	failedSyscalls, ok := whitelistWCounts[FailedSyscallMapping]

	if !ok {
		return whitelists, nil
	}

	for s := range maps.Keys(failedSyscalls) {
		for _, w := range whitelists {
			w.Syscalls = append(w.Syscalls, s)
		}
	}

	return whitelists, nil
}
